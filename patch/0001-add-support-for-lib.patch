From 36ce719d4a7a29816167e10d3e3aab03db16531e Mon Sep 17 00:00:00 2001
From: jingd2 <jingd2@xiaopeng.com>
Date: Wed, 24 Dec 2025 17:26:32 +0800
Subject: [PATCH] add support for lib

---
 Makefile |  14 ++++
 qdl.c    | 213 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 qdl.h    |  65 +++++++++++++++++
 util.c   |   5 ++
 ux.c     |  60 ++++++++++++----
 5 files changed, 341 insertions(+), 16 deletions(-)

diff --git a/Makefile b/Makefile
index 7ec4a17..4abdc06 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,11 @@
+LIBQDL_OBJS := firehose.o io.o qdl.o sahara.o util.o patch.o program.o read.o sha2.o sim.o ufs.o usb.o ux.o oscompat.o vip.o sparse.o gpt.o
+LIBQDL := libqdl.dylib
+
+$(LIBQDL): $(LIBQDL_OBJS)
+	$(CC) -dynamiclib -o $@ $^ $(LDFLAGS)
+
+.PHONY: lib
+lib: $(LIBQDL)
 QDL := qdl
 RAMDUMP := qdl-ramdump
 VERSION := $(or $(VERSION), $(shell git describe --dirty --always --tags 2>/dev/null), "unknown-version")
@@ -58,6 +66,12 @@ clean:
 	rm -f $(RAMDUMP) $(RAMDUMP_OBJS)
 	rm -f $(KS_OUT) $(KS_OBJS)
 	rm -f $(MANPAGES)
+	rm -f $(LIBQDL) $(LIBQDL_OBJS)
+install-lib: $(LIBQDL)
+	install -d $(DESTDIR)$(prefix)/lib
+	install -m 755 $(LIBQDL) $(DESTDIR)$(prefix)/lib
+	install -d $(DESTDIR)$(prefix)/include
+	install -m 644 qdl.h $(DESTDIR)$(prefix)/include
 	rm -f compile_commands.json
 	rm -f version.h .version.h
 	rm -f $(CHECKPATCH)
diff --git a/qdl.c b/qdl.c
index cd94600..fdd9527 100644
--- a/qdl.c
+++ b/qdl.c
@@ -1,3 +1,8 @@
+// ===================
+// QDL C API for GUI/Swift
+// ===================
+#include <libusb.h>
+#include <limits.h>
 // SPDX-License-Identifier: BSD-3-Clause
 /*
  * Copyright (c) 2016-2017, Linaro Ltd.
@@ -478,12 +483,22 @@ int main(int argc, char **argv)
 		{"dry-run", no_argument, 0, 'n'},
 		{"create-digests", required_argument, 0, 't'},
 		{"slot", required_argument, 0, 'T'},
+		{"list-devices", no_argument, 0, 'L'},
 		{"help", no_argument, 0, 'h'},
 		{0, 0, 0, 0}
 	};
 
-	while ((opt = getopt_long(argc, argv, "dvi:lu:S:D:s:fcnt:T:h", options, NULL)) != -1) {
+	while ((opt = getopt_long(argc, argv, "dvi:lu:S:D:s:fcnt:T:Lh", options, NULL)) != -1) {
 		switch (opt) {
+		case 'L': {
+			qdl_device_info_t devs[16];
+			int n = qdl_list_devices(devs, 16);
+			printf("Found %d QDL device(s):\n", n);
+			for (int i = 0; i < n; ++i) {
+				printf("  [%d] serial: %s, product: %s\n", i, devs[i].serial, devs[i].product);
+			}
+			return 0;
+		}
 		case 'd':
 			qdl_debug = true;
 			break;
@@ -661,3 +676,199 @@ out_cleanup:
 
 	return !!ret;
 }
+
+
+
+int qdl_list_devices(qdl_device_info_t *devices, int max_devices) {
+	struct libusb_device **devs;
+	ssize_t cnt, i;
+	int found = 0;
+	int ret;
+	libusb_context *ctx = NULL;
+
+	if (!devices || max_devices <= 0)
+		return 0;
+
+	ret = libusb_init(&ctx);
+	if (ret < 0)
+		return 0;
+
+	cnt = libusb_get_device_list(ctx, &devs);
+	if (cnt < 0) {
+		libusb_exit(ctx);
+		return 0;
+	}
+
+	for (i = 0; devs[i] && found < max_devices; i++) {
+		struct libusb_device_descriptor desc;
+
+		ret = libusb_get_device_descriptor(devs[i], &desc);
+		if (ret < 0)
+			continue;
+
+		/* match only Qualcomm EDL devices */
+		if (desc.idVendor != 0x05c6)
+			continue;
+		if (desc.idProduct != 0x9008 && desc.idProduct != 0x900e && desc.idProduct != 0x901d)
+			continue;
+
+		libusb_device_handle *handle = NULL;
+		ret = libusb_open(devs[i], &handle);
+		if (ret < 0 || !handle)
+			continue;
+
+		/* initialize output slot */
+		memset(&devices[found], 0, sizeof(devices[found]));
+
+		unsigned char buf[256] = {0};
+
+		/* read product string (if present) */
+		if (desc.iProduct) {
+			ret = libusb_get_string_descriptor_ascii(handle, desc.iProduct, buf, sizeof(buf));
+			if (ret > 0)
+				strncpy(devices[found].product, (char *)buf, sizeof(devices[found].product) - 1);
+		}
+
+		/* read serial descriptor (if present) */
+		buf[0] = '\0';
+		if (desc.iSerialNumber) {
+			ret = libusb_get_string_descriptor_ascii(handle, desc.iSerialNumber, buf, sizeof(buf));
+			if (ret > 0)
+				strncpy(devices[found].serial, (char *)buf, sizeof(devices[found].serial) - 1);
+		}
+
+		/* if serial still empty, try to extract from product string e.g. "..._SN:XXXX" */
+		if (devices[found].serial[0] == '\0' && devices[found].product[0]) {
+			char *p = strstr(devices[found].product, "_SN:");
+			if (!p)
+				p = strstr(devices[found].product, "SN:");
+			if (p) {
+				/* move past the marker */
+				if (strncmp(p, "_SN:", 4) == 0)
+					p += 4;
+				else if (strncmp(p, "SN:", 3) == 0)
+					p += 3;
+
+				size_t sn_len = strcspn(p, " _\t");
+				if (sn_len > 0) {
+					if (sn_len >= sizeof(devices[found].serial))
+						sn_len = sizeof(devices[found].serial) - 1;
+					strncpy(devices[found].serial, p, sn_len);
+					devices[found].serial[sn_len] = '\0';
+				}
+			}
+		}
+
+		libusb_close(handle);
+		found++;
+	}
+
+	libusb_free_device_list(devs, 1);
+	libusb_exit(ctx);
+	return found;
+}
+
+int qdl_run(
+	qdl_mode_t mode,
+	const char *serial,
+	qdl_storage_type_t storage_type,
+	const char *prog_mbn,
+	const char **xml_files,
+	int xml_file_count,
+	bool allow_missing,
+	const char *include_dir,
+	unsigned int out_chunk_size
+) {
+	int ret = 0;
+	struct qdl_device *qdl = NULL;
+	struct sahara_image sahara_images[MAPPING_SZ] = {};
+	bool single_image = true;
+	int i, type;
+	qdl = qdl_init(QDL_DEVICE_USB);
+	if (!qdl) return QDL_ERR_GENERIC;
+	if (out_chunk_size)
+		qdl_set_out_chunk_size(qdl, out_chunk_size);
+	ux_init();
+
+	/* Log parameters passed from UI to help debugging and verification */
+	{
+		const char *mode_str = (mode == QDL_MODE_PROVISION) ? "PROVISION" : "FLASH";
+		const char *storage_str = "unknown";
+		switch (storage_type) {
+		case QDL_STORAGE_EMMC: storage_str = "emmc"; break;
+		case QDL_STORAGE_NAND: storage_str = "nand"; break;
+		case QDL_STORAGE_UFS: storage_str = "ufs"; break;
+		case QDL_STORAGE_NVME: storage_str = "nvme"; break;
+		case QDL_STORAGE_SPINOR: storage_str = "spinor"; break;
+		default: break;
+		}
+
+		ux_info("qdl_run called: mode=%s, serial=%s, storage=%s, prog_mbn=%s, xml_file_count=%d, allow_missing=%d, include_dir=%s, out_chunk_size=%u\n",
+			 mode_str,
+			 serial ? serial : "(null)",
+			 storage_str,
+			 prog_mbn ? prog_mbn : "(null)",
+			 xml_file_count,
+			 allow_missing ? 1 : 0,
+			 include_dir ? include_dir : "(null)",
+			 out_chunk_size);
+
+		if (xml_files && xml_file_count > 0) {
+			for (int xi = 0; xi < xml_file_count; ++xi) {
+				ux_info("  xml_files[%d] = %s\n", xi, xml_files[xi] ? xml_files[xi] : "(null)");
+			}
+		}
+	}
+	// 加载 programmer
+	char prog_mbn_buf[PATH_MAX];
+	strncpy(prog_mbn_buf, prog_mbn, sizeof(prog_mbn_buf)-1);
+	prog_mbn_buf[sizeof(prog_mbn_buf)-1] = 0;
+	ret = decode_programmer(prog_mbn_buf, sahara_images, &single_image);
+	if (ret < 0) {
+		qdl_deinit(qdl);
+		return QDL_ERR_GENERIC;
+	}
+	// 加载 xml 文件
+	for (i = 0; i < xml_file_count; ++i) {
+		type = detect_type(xml_files[i]);
+		if (type < 0 || type == QDL_FILE_UNKNOWN) {
+			qdl_deinit(qdl);
+			return QDL_ERR_GENERIC;
+		}
+		switch (type) {
+		case QDL_FILE_PATCH:
+			ret = patch_load(xml_files[i]);
+			if (ret < 0) { qdl_deinit(qdl); return QDL_ERR_GENERIC; }
+			break;
+		case QDL_FILE_PROGRAM:
+			ret = program_load(xml_files[i], storage_type == QDL_STORAGE_NAND, allow_missing, include_dir);
+			if (ret < 0) { qdl_deinit(qdl); return QDL_ERR_FLASH_FAILED; }
+			break;
+		case QDL_FILE_READ:
+			ret = read_op_load(xml_files[i], include_dir);
+			if (ret < 0) { qdl_deinit(qdl); return QDL_ERR_GENERIC; }
+			break;
+		case QDL_FILE_UFS:
+			if (storage_type != QDL_STORAGE_UFS) { qdl_deinit(qdl); return QDL_ERR_GENERIC; }
+			ret = ufs_load(xml_files[i], mode == QDL_MODE_PROVISION);
+			if (ret < 0) { qdl_deinit(qdl); return QDL_ERR_PROVISION_FAILED; }
+			break;
+		default:
+			qdl_deinit(qdl);
+			return QDL_ERR_GENERIC;
+		}
+	}
+	ret = qdl_open(qdl, serial);
+	if (ret) { qdl_deinit(qdl); return QDL_ERR_DEVICE_NOT_FOUND; }
+	qdl->storage_type = storage_type;
+	ret = sahara_run(qdl, sahara_images, single_image, NULL, NULL);
+	if (ret < 0) { qdl_close(qdl); qdl_deinit(qdl); return QDL_ERR_GENERIC; }
+	if (mode == QDL_MODE_PROVISION || (storage_type == QDL_STORAGE_UFS && ufs_need_provisioning()))
+		ret = firehose_provision(qdl);
+	else
+		ret = firehose_run(qdl);
+	qdl_close(qdl);
+	qdl_deinit(qdl);
+	if (ret < 0) return (mode == QDL_MODE_PROVISION) ? QDL_ERR_PROVISION_FAILED : QDL_ERR_FLASH_FAILED;
+	return QDL_OK;
+}
\ No newline at end of file
diff --git a/qdl.h b/qdl.h
index 7949d3e..2fac050 100644
--- a/qdl.h
+++ b/qdl.h
@@ -110,10 +110,75 @@ void ux_progress(const char *fmt, unsigned int value, unsigned int size, ...);
 
 void print_version(void);
 
+/* Progress callback for GUI clients. Called for each ux_progress emission.
+ * task: human-readable task name (NUL-terminated).
+ * value: current progress value.
+ * total: total value.
+ * userdata: user-provided pointer passed through qdl_set_progress_callback.
+ */
+typedef void (*qdl_progress_cb_t)(const char *task, unsigned int value, unsigned int total, void *userdata);
+
+/* Register a progress callback. Passing NULL clears the callback. Thread-unsafe; callers
+ * should register before starting long-running operations or ensure synchronization.
+ */
+void qdl_set_progress_callback(qdl_progress_cb_t cb, void *userdata);
+
 int parse_storage_address(const char *address, int *physical_partition,
 			  unsigned int *start_sector, unsigned int *num_sectors,
 			  char **gpt_partition);
 
 extern bool qdl_debug;
 
+// ===================
+// QDL C API for GUI/Swift
+// ===================
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stddef.h>
+#include <stdbool.h>
+
+typedef struct {
+    char serial[64];
+    char product[64];
+} qdl_device_info_t;
+
+typedef enum {
+    QDL_MODE_FLASH,
+    QDL_MODE_PROVISION
+} qdl_mode_t;
+
+typedef enum qdl_storage_type qdl_storage_type_t;
+
+typedef enum {
+    QDL_OK = 0,
+    QDL_ERR_GENERIC = -1,
+    QDL_ERR_DEVICE_NOT_FOUND = -2,
+    QDL_ERR_FLASH_FAILED = -3,
+    QDL_ERR_PROVISION_FAILED = -4,
+} qdl_error_t;
+
+// 获取可用设备列表，返回设备数量，devices为输出数组，max_devices为最大数量
+int qdl_list_devices(qdl_device_info_t *devices, int max_devices);
+
+// 烧录/Provision 操作
+int qdl_run(
+    qdl_mode_t mode,
+    const char *serial,
+    qdl_storage_type_t storage_type,
+    const char *prog_mbn,
+    const char **xml_files,
+    int xml_file_count,
+    bool allow_missing,
+    const char *include_dir,
+    unsigned int out_chunk_size
+);
+
+const char* qdl_version(void);
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif
diff --git a/util.c b/util.c
index 70cbd43..1a8fbe1 100644
--- a/util.c
+++ b/util.c
@@ -1,3 +1,8 @@
+#include "qdl.h"
+#include "version.h"
+const char* qdl_version(void) {
+	return VERSION;
+}
 // SPDX-License-Identifier: BSD-3-Clause
 /*
  * Copyright (c) 2016, Bjorn Andersson <bjorn@kryo.se>
diff --git a/ux.c b/ux.c
index 587daa2..07b7df3 100644
--- a/ux.c
+++ b/ux.c
@@ -22,6 +22,10 @@ static const char * const progress_dashes = DASHES;
 static unsigned int ux_width;
 static unsigned int ux_cur_line_length;
 
+/* Progress callback storage for GUI clients */
+static qdl_progress_cb_t progress_cb = NULL;
+static void *progress_userdata = NULL;
+
 /*
  * Levels of output:
  *
@@ -128,7 +132,7 @@ void ux_debug(const char *fmt, ...)
 void ux_progress(const char *fmt, unsigned int value, unsigned int max, ...)
 {
 	static struct timeval last_progress_update;
-	unsigned long elapsed_us;
+	unsigned long elapsed_us = 0;
 	unsigned int bar_length;
 	unsigned int bars;
 	unsigned int dashes;
@@ -136,36 +140,62 @@ void ux_progress(const char *fmt, unsigned int value, unsigned int max, ...)
 	char task_name[32];
 	float percent;
 	va_list ap;
+	bool allow_update = true;
 
-	/* Don't print progress is window is too narrow, or if stdout is redirected */
-	if (ux_width < 30)
-		return;
-
-	/* Avoid updating the console more than UX_PROGRESS_REFRESH_RATE per second */
+	/* Calculate throttle interval (shared with printing). We compute elapsed
+	 * time first so the callback can still be invoked when stdout is not a
+	 * suitable terminal (ux_width < 30). This preserves rate-limiting while
+	 * allowing GUI clients to receive progress events. */
+	gettimeofday(&now, NULL);
 	if (last_progress_update.tv_sec) {
-		gettimeofday(&now, NULL);
 		elapsed_us = (now.tv_sec - last_progress_update.tv_sec) * 1000000 +
-			     (now.tv_usec - last_progress_update.tv_usec);
-
+					 (now.tv_usec - last_progress_update.tv_usec);
 		if (elapsed_us < (1000000 / UX_PROGRESS_REFRESH_RATE))
-			return;
+			allow_update = false;
 	}
 
+	/* Format task name once */
 	va_start(ap, max);
 	vsnprintf(task_name, sizeof(task_name), fmt, ap);
 	va_end(ap);
 
+	/* Invoke callback if registered and we're allowed by throttle, or if the
+	 * task is complete (value >= max) in which case we always emit a final
+	 * update so UIs can finish. */
+	if (progress_cb) {
+		if (allow_update || (max != 0 && value >= max)) {
+			progress_cb(task_name, value, max, progress_userdata);
+			/* record update time */
+			gettimeofday(&last_progress_update, NULL);
+		}
+	}
+
+	/* If the terminal is too narrow or stdout redirected, skip printing but
+	 * do not suppress callbacks (callbacks already handled above). */
+	if (ux_width < 30)
+		return;
+
+	/* If throttled, skip printing to avoid excessive console updates. */
+	if (!allow_update)
+		return;
+
+	percent = (float)value / (max ? max : 1);
 	bar_length = ux_width - (20 + 4 + 6);
-	percent = (float)value / max;
 	bars = percent * bar_length;
 	dashes = bar_length - bars;
 
 	printf("%-20.20s [%.*s%.*s] %1.2f%%%n\r", task_name,
-	       bars, progress_hashes,
-	       dashes, progress_dashes,
-	       percent * 100,
-	       &ux_cur_line_length);
+		   bars, progress_hashes,
+		   dashes, progress_dashes,
+		   percent * 100,
+		   &ux_cur_line_length);
 	fflush(stdout);
 
 	gettimeofday(&last_progress_update, NULL);
 }
+
+void qdl_set_progress_callback(qdl_progress_cb_t cb, void *userdata)
+{
+	progress_cb = cb;
+	progress_userdata = userdata;
+}
-- 
2.50.1 (Apple Git-155)

